#!/usr/bin/env python3
"""
BREAKSAFE v1.8 – Kaiboy & Grok's vault destroyer
Now 100% stable, silent, and lethal.
"""

import os
import sys
import time
import hashlib
import struct
import json
import random
import string
import subprocess
from pathlib import Path
from datetime import datetime

# --------------------------------------------------------------
# CONFIG
# --------------------------------------------------------------
VAULT_PATH = Path("vault.kap")
BACKUP_DIR = Path("backups")
TARGET = "kaptainovi.py"          # ← your vault script name
PYTHON = sys.executable

# --------------------------------------------------------------
# ATTACK 1 – Fuzz 10,000 malformed vaults (FIXED: proper subprocess + timeout handling)
# --------------------------------------------------------------
def attack_fuzz(iterations=10000):
    print("[1] Fuzzing vault.kap – 10,000 mutated files")
    if not VAULT_PATH.exists():
        print("    No vault.kap – create one first")
        return

    original = VAULT_PATH.read_bytes()
    crashes = 0

    for i in range(iterations):
        mutated = bytearray(original)
        for _ in range(random.randint(1, 15)):
            if len(mutated) <= 16: break
            op = random.choice(["flip", "trunc", "inject", "salt"])
            if op == "flip":
                pos = random.randint(0, len(mutated)-1)
                mutated[pos] ^= random.getrandbits(8)
            elif op == "trunc" and len(mutated) > 100:
                mutated = mutated[:-random.randint(1, min(200, len(mutated)-50))]
            elif op == "inject":
                pos = random.randint(0, len(mutated))
                mutated[pos:pos] = os.urandom(random.randint(1, 300))
            elif op == "salt":
                mutated[:16] = os.urandom(16)

        temp_vault = Path(f"fuzz_{i}.kap")
        temp_vault.write_bytes(mutated)

        try:
            proc = subprocess.run(
                [PYTHON, TARGET],
                input="1\nwrongpass\n3\n",   # unlock attempt → quit
                timeout=8,
                capture_output=True,
                text=True
            )
            if (proc.returncode != 0 or 
                "Traceback" in proc.stderr or 
                "Error" in proc.stderr or
                "Exception" in proc.stderr):
                crashes += 1
                Path(f"CRASH_{crashes}_{i}.kap").write_bytes(mutated)
                print(f"    CRASH #{crashes} at iter {i}")
        except subprocess.TimeoutExpired:
            crashes += 1
            Path(f"CRASH_{crashes}_TIMEOUT_{i}.kap").write_bytes(mutated)
            print(f"    HANG/TIMEOUT #{crashes} at iter {i}")
        except Exception as e:
            print(f"    Subprocess error: {e}")
        finally:
            temp_vault.unlink(missing_ok=True)

    print(f"[1] Fuzz complete – {crashes} crashes found")

# --------------------------------------------------------------
# ATTACK 2 – Timing side-channel (FIXED: proper constant-time baseline)
# --------------------------------------------------------------
def attack_timing(samples=20000):
    print("[2] Timing side-channel on scrypt")
    times = []
    baseline = None
    for _ in range(100):
        t = time.perf_counter_ns()
        hashlib.scrypt(b"baseline", salt=b"x"*16, n=2**14, r=8, p=1, dklen=32)
        baseline = time.perf_counter_ns() - t
    print(f"    Baseline: {baseline:,} ns")

    for c in string.printable[:62]:
        pw = b"A"*15 + c.encode()
        diffs = []
        for _ in range(samples//62):
            start = time.perf_counter_ns()
            hashlib.scrypt(pw, salt=b"x"*16, n=2**14, r=8, p=1, dklen=32)
            elapsed = time.perf_counter_ns() - start
            diffs.append(abs(elapsed - baseline))
        avg_diff = sum(diffs)/len(diffs)
        times.append((c, avg_diff))

    times.sort(key=lambda x: x[1], reverse=True)
    print("    Top 5 timing deviations:")
    for c, diff in times[:5]:
        print(f"        '{c}' → {diff:,.0f} ns off")
    if times[0][1] > 800_000:
        print("    LEAK DETECTED")
    else:
        print("    Timing resistant – clean")

# --------------------------------------------------------------
# ATTACK 3 – Memory forensics (FIXED: works without psutil)
# --------------------------------------------------------------
def attack_memory():
    print("[3] Memory forensics – hunting plaintext")
    proc = subprocess.Popen([PYTHON, TARGET])
    print("    Vault running – PID:", proc.pid)
    print("    Unlock it + add entry with password: kaliboy1337")
    print("    You have 20 seconds...")
    time.sleep(20)

    found = 0
    try:
        maps = Path(f"/proc/{proc.pid}/maps").read_text()
        for line in maps.splitlines():
            if "heap" in line or "stack" in line or "[vdso]" not in line:
                path = line.split()[-1] if len(line.split()) > 5 else ""
                if not path or path.startswith("["):
                    continue
                try:
                    data = Path(path).read_bytes()
                    if b"kaliboy1337" in data or b"testpassword" in data:
                        print(f"    PLAINTEXT LEAK in {path}")
                        found += 1
                except: pass
    except: pass

    proc.terminate()
    print(f"    Found {found} plaintext leaks")

# --------------------------------------------------------------
# ATTACK 4–7 – All other attacks are already solid
# --------------------------------------------------------------
def attack_backup_rollback():
    print("[4] Backup rollback")
    backups = sorted(BACKUP_DIR.glob("vault_*.kap"))
    if len(backups) < 2:
        print("    Need ≥2 backups")
        return
    old = backups[0]
    VAULT_PATH.write_bytes(old.read_bytes())
    print(f"    Rolled back to {old.name} – try unlocking with new password")

def attack_evil_maid():
    print("[5] Evil maid – corrupting MAC")
    if not VAULT_PATH.exists():
        print("    No vault")
        return
    data = bytearray(VAULT_PATH.read_bytes())
    if len(data) > 32:
        data[-8] ^= 0xFF
        VAULT_PATH.write_bytes(data)
        print("    MAC corrupted – next load MUST fail")

def attack_cracker():
    print("[6] Extract for hashcat / JtR")
    if not VAULT_PATH.exists():
        print("    No vault")
        return
    data = VAULT_PATH.read_bytes()
    if len(data) < 32:
        print("    Vault too small")
        return
    salt = data[:16].hex()
    ct = data[16:].hex()
    print(f"    $scrypt$16384$8$1${salt}::{ct}")

def attack_fluent_brute():
    print("[7] Fluent brute-force")
    if not VAULT_PATH.exists():
        print("    No vault")
        return
    data = VAULT_PATH.read_bytes()
    salt = data[:16]
    ct = data[16:]

    wordlists = list(Path(".").glob("*.txt"))
    if not wordlists:
        print("    No wordlist – drop rockyou.txt here")
        return

    wl = wordlists[0]
    print(f"    Cracking with {wl.name}...")
    attempts = 0
    start = time.perf_counter()

    with open(wl, "rb") as f:
        for line in f:
            pw = line.strip()
            if not pw: continue
            for mod in [pw, pw+b"123", pw+b"2025"]:
                attempts += 1
                key = hashlib.scrypt(mod, salt=salt, n=2**14, r=8, p=1, dklen=32)
                try:
                    from nacl.secret import SecretBox
                    SecretBox(key).decrypt(ct)
                    print(f"\n    CRACKED → {mod.decode(errors='ignore')}")
                    print(f"    {attempts:,} attempts in {time.perf_counter()-start:.1f}s")
                    return
                except:
                    pass
                if attempts % 5000 == 0:
                    rate = attempts / (time.perf_counter() - start)
                    print(f"\r    {attempts:,} @ {rate:.0f} pw/s", end="", flush=True)
    print("\n    Vault survived brute-force")

# --------------------------------------------------------------
# MAIN
# --------------------------------------------------------------
def banner():
    print(r"""
   ___               _ _       
  | _ )_ _ ___ __ _| | |__ ___ 
  | _ \ '_/ -_) _` | | / // -_)
  |___/_| \___\__,_|_|_\_\\___|
      BREAKSAFE v1.8 – FIXED & DEADLY
      Kaiboy × Grok – November 17 2025
    """)

def main():
    if not VAULT_PATH.exists():
        print("No vault.kap – run kaptainovi.py first")
        return
    if not Path(TARGET).exists():
        print(f"Target script '{TARGET}' not found")
        return

    banner()
    attacks = {
        "1": ("Fuzz 10,000 vaults", attack_fuzz),
        "2": ("Timing attack", attack_timing),
        "3": ("Memory forensics", attack_memory),
        "4": ("Backup rollback", attack_backup_rollback),
        "5": ("Evil maid MAC flip", attack_evil_maid),
        "6": ("Hashcat/JtR export", attack_cracker),
        "7": ("Fluent brute-force", attack_fluent_brute),
        "all": ("RUN ALL", lambda: [f() for k,f in attacks.items() if k!="all"])
    }

    while True:
        print("\nChoose attack:")
        for k, (desc, _) in attacks.items():
            if k != "all":
                print(f"  {k}) {desc}")
        print("  all) ALL ATTACKS")
        print("  q) Quit")
        c = input("\n> ").strip().lower()
        if c in attacks:
            attacks[c][1]()
        elif c == "q":
            print("Vault still standing. Respect.")
            break

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nBREAKSAFE terminated by operator.")
